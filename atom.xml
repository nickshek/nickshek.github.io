<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Nick Shek&#039;s Blog]]></title>
    <link href="/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2016-04-14T20:32:36+08:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[使用Apache設定Alias時出現403 Foridden]]></title>
            <link href="/b/使用Apache設定Alias時出現403 Foridden"/>
            <updated>2016-04-16T00:00:00+08:00</updated>
            <id>/b/使用Apache設定Alias時出現403 Foridden</id>
            <content type="html"><![CDATA[<p>這個錯誤其實是好常見的 ，如果在apache 看見 access denied because search permissions are missing on a component of the path ，
即表示<strong>根目錄至Alias 的目標資料夾</strong>中任意一個資料夾沒有execute permission!例如:</p>

<p>如果你alias的目標資夾是 <code>/usr/local/apache2/htdocs/foo</code> ，請確保以下資料夾有execute permission</p>

<p>/
/usr/
/usr/local/
/usr/local/apache2/
/usr/local/apache2/htdocs/
/usr/local/apache2/htdocs/foo/</p>

<p>owner 無須設定是apache user
因此，解決方法如下</p>

<pre><code>cd /usr/local/apache2/htdocs/foo

ls -la
chmod +x .
cd ..
# 重覆直至去到 /
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Failed to listen on localhost:8000 (reason: Address already in use)]]></title>
            <link href="/b/Failed to listen on localhost:8000 (reason: Address already in use)"/>
            <updated>2015-11-15T00:00:00+08:00</updated>
            <id>/b/Failed to listen on localhost:8000 (reason: Address already in use)</id>
            <content type="html"><![CDATA[<p>若使用 <code>php -S localhost:8000</code>來進行development時，沒有使用control +C 結束程序，便會發生該問題，因此可以建立以下bashscript結束名為"php"的proceses</p>

<pre><code class="bash">#!/bin/bash
pid=$(ps -fe | grep '[p]hp' | awk '{print $2}')
if [[ -n $pid ]]; then
    kill $pid
else
    echo "Does not exist"
fi
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Socket.io 1.3.5 cdn 同源問題]]></title>
            <link href="/b/Socket.io 1.3"/>
            <updated>2015-04-15T00:00:00+08:00</updated>
            <id>/b/Socket.io 1.3</id>
            <content type="html"><![CDATA[<p>假設己經有一個HTTPS加密網站，為了令網站更快速。因此Socket.io使用了以下的javascript cdn :</p>

<pre><code class="html">&lt;script src="https://cdn.socket.io/socket.io-1.3.4.js"&gt;&lt;/script&gt;
</code></pre>

<p>但是socket.io server 會在 polling的請求回覆400 Bad request</p>

<p>解決方法是從Socket.io依賴的原始碼找出return Access-Control-Allow-Origin Header的地方,根據socket.io v1.3.5 的源始碼,return Access-Control-Allow-Origin Header的地方位於node_modules/socket.io/node_modules/engine.io/lib/transports/polling-xhr.js</p>

<pre><code class="javascript">/**
 * Returns headers for a response.
 *
 * @param {http.ServerRequest} request
 * @param {Object} extra headers
 * @api private
 */

XHR.prototype.headers = function(req, headers){
  headers = headers || {};

  if (req.headers.origin) {
    headers['Access-Control-Allow-Credentials'] = 'true';
    headers['Access-Control-Allow-Origin'] = req.headers.origin;
  } else {
    headers['Access-Control-Allow-Origin'] = '*';
  }

  this.emit('headers', headers);
  return headers;
};
</code></pre>

<p>將該function 改成</p>

<pre><code class="javascript">/**
 * Returns headers for a response.
 *
 * @param {http.ServerRequest} request
 * @param {Object} extra headers
 * @api private
 */

XHR.prototype.headers = function(req, headers){
  headers = headers || {};

  if (req.headers.origin) {
    headers['Access-Control-Allow-Credentials'] = 'true';
    if(req.headers.origin == "https://www.example-domain.com/"){
        headers['Access-Control-Allow-Origin'] = "https://cdn.socket.io/";
    }else{
        headers['Access-Control-Allow-Origin'] = req.headers.origin;
    }
  } else {
    headers['Access-Control-Allow-Origin'] = '*';
  }

  this.emit('headers', headers);
  return headers;
};
</code></pre>

<p>或者直接新增　<code>headers['Access-Control-Allow-Origin'] = "https://cdn.socket.io/";</code>　雖然修改方法很醜。但至少可以令網站使用Socket.io CDN</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[如何令git repo 連接己經存在的heroku app?]]></title>
            <link href="/b/如何令git repo 連接己經存在的heroku app"/>
            <updated>2015-04-05T00:00:00+08:00</updated>
            <id>/b/如何令git repo 連接己經存在的heroku app</id>
            <content type="html"><![CDATA[<p>假設你己經在<a href="https://toolbelt.heroku.com/">https://toolbelt.heroku.com/</a>下載了heroku 工具程式.若想把原本的應用程式連接至heroku只需要在程式的根目錄輸入<code>heroku create</code>,但是這樣會建立了一個全新的heroku程式。</p>

<p>若我在heroku己經有一個應用程式為 project , 我想將原本的git 連接至 project 而不是重新建立一個新的應用程式,只需要在程式的根目錄輸入 <code>heroku git:remote -a project</code></p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Missing `secret_key_base` for &#039;production&#039; environment, set this value in `config/secrets.yml`]]></title>
            <link href="/b/Missing `secret_key_base` for &#039;production&#039; environment"/>
            <updated>2015-03-14T00:00:00+08:00</updated>
            <id>/b/Missing `secret_key_base` for &#039;production&#039; environment</id>
            <content type="html"><![CDATA[<p>執行<code>rake secret</code> 在.bashrc 或在apache 使用SetEnv指令 設定環境變數 SECRET_KEY_BASE 就完成了。不建議把 secret token 設定在 config/secrets.yml</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[如何令你使用SSH時更安全?]]></title>
            <link href="/b/如何令你使用SSH時更安全"/>
            <updated>2015-03-02T00:00:00+08:00</updated>
            <id>/b/如何令你使用SSH時更安全</id>
            <content type="html"><![CDATA[<p>要令SSH登入更安全，最簡單的方法是取消密碼登入。而使用公開金鑰。</p>

<p>在Client輸入</p>

<pre><code class="bash">ssh-keygen -t rsa
</code></pre>

<p>建議輸入passphrase。之後輸入</p>

<pre><code class="bash">chmod 700 ~/.ssh
</code></pre>

<p>之後將產生的Public Key (e.g id_rsa.pub) 複製至SSH Server。</p>

<p>登入SSH Server，將Public Key的內容加至 .ssh/authorized_keys:</p>

<pre><code class="bash">cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys
</code></pre>

<p>之後開啟另一個Terminal 測試SSH登入是否只需要輸入passphrase來找替原本的使用者密碼</p>

<p>之後輸入<code>sudo vim /etc/ssh/sshd_config</code></p>

<p>將 Port 22 修改為其他Port，使用ssh 時用-p 選項指定PORT Number</p>

<p>將<code>#PasswordAuthentication yes</code> 改為<code>PasswordAuthentication no</code></p>

<p>重啟SSH Service就完成了</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[更新git branch所有舊有的電子郵件地址]]></title>
            <link href="/b/更新git branch所有舊有的電子郵件地址"/>
            <updated>2015-02-24T00:00:00+08:00</updated>
            <id>/b/更新git branch所有舊有的電子郵件地址</id>
            <content type="html"><![CDATA[<p>修改以下的OLD_EMAIL，CORRECT_NAME 及 CORRECT_EMAIL 的值再把以下script移至想更新的git repository 再執行就可以了</p>

<script src="https://gist.github.com/octocat/0831f3fbd83ac4d46451.js"></script>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[git://github.com/reactjs/react-rails.git (at master) is not yet checked out. Run `bundle install` first.]]></title>
            <link href="/b/react-rails.git (at master) is not yet checked out"/>
            <updated>2015-01-26T00:00:00+08:00</updated>
            <id>/b/react-rails.git (at master) is not yet checked out</id>
            <content type="html"><![CDATA[<p>根據<a href="https://github.com/bundler/bundler/blob/master/ISSUES.md">https://github.com/bundler/bundler/blob/master/ISSUES.md</a>，解決方是執行以下程式碼，重新安裝 dependencies :</p>

<pre><code class="bash"># remove user-specific gems and git repos
rm -rf ~/.bundle/ ~/.gem/bundler/ ~/.gems/cache/bundler/

# remove system-wide git repos and git checkouts
rm -rf $GEM_HOME/bundler/ $GEM_HOME/cache/bundler/

# remove project-specific settings
rm -rf .bundle/

# remove project-specific cached gems and repos
rm -rf vendor/cache/

# remove the saved resolve of the Gemfile
rm -rf Gemfile.lock

# uninstall the rubygems-bundler and open_gem gems
rvm gemset use global # if using rvm
gem uninstall rubygems-bundler open_gem

# try to install one more time
bundle install
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[debug.py =&gt; IndexError: list index out of range]]></title>
            <link href="/b/debug"/>
            <updated>2015-01-22T00:00:00+08:00</updated>
            <id>/b/debug</id>
            <content type="html"><![CDATA[<p>若該錯誤來自Django項目的debug.py，解決方法是修改_get_lines_from_file方法，把以下這一行:</p>

<pre><code class="python">source = f.readlines()
</code></pre>

<p>改為</p>

<pre><code class="python">source = f.read().splitlines()
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[從http://fontello.com/下載font icon,及使用Nokogiri製作一張font icon class 的名單]]></title>
            <link href="/b/從fontello下載font icon,及使用Nokogiri製作一張font icon class 的名單"/>
            <updated>2015-01-20T00:00:00+08:00</updated>
            <id>/b/從fontello下載font icon,及使用Nokogiri製作一張font icon class 的名單</id>
            <content type="html"><![CDATA[<p>從<a href="http://fontello.com/">http://fontello.com/</a>下載font icon，zip檔入面有demo.html，列出如何使用fontello icon ，我的目的是利Nokogiri在rake task以ruby list 形式列印出所有class name，以下是該rake task的程式碼 :</p>

<pre><code class="ruby">namespace :dev do
  task :font_icon_list do
    text = open(Rails.root.join('doc', 'fontello-c340d124','demo.html')).read
    html_doc = Nokogiri::HTML(text)
    font_icon_list = html_doc.xpath(%{//div[@class="row"]//div//span[@class="i-name"]//text()})
    font_icon_list_code = %{["#{font_icon_list.to_a.join(%{","})}"]}
    puts font_icon_list_code
  end
end
</code></pre>

<p>最後執行rake task輸出結果</p>

<pre><code class="bash">rake dev:font_icon_list &gt; result.txt
</code></pre>
]]></content>
        </entry>
    </feed>