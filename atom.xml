<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Nick Shek&#039;s Blog]]></title>
    <link href="/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2016-07-09T00:34:37+08:00</updated>
    <id>/</id>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[安裝Ubuntu Server至舊Notebook注意事項]]></title>
            <link href="/b/安裝Ubuntu Server至舊Notebook注意事項"/>
            <updated>2016-06-28T00:00:00+08:00</updated>
            <id>/b/安裝Ubuntu Server至舊Notebook注意事項</id>
            <content type="html"><![CDATA[<p>若家中有Notebook 不再使用，用來安裝Ubuntu Server 是一個好主意。Ubuntu Server 的下載連結如下:</p>

<p><a href="http://www.ubuntu.com/download/server">http://www.ubuntu.com/download/server</a></p>

<p>下載完iso 後便可以參考以下連結去建立USB安裝碟</p>

<p>Windows: <a href="http://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows">http://www.ubuntu.com/download/desktop/create-a-usb-stick-on-windows</a></p>

<p>Ubuntu: <a href="http://www.ubuntu.com/download/desktop/create-a-usb-stick-on-ubuntu">http://www.ubuntu.com/download/desktop/create-a-usb-stick-on-ubuntu</a></p>

<p>安裝後，為了避免開機後合上Notebook後會進入睡眠狀態，可以修改<code>/etc/systemd/logind.conf</code>
加入<code>HandleLidSwitch=ignore</code> 。
最後執行<code>sudo service restart systemd-logind</code></p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[使用sftp時出現&quot;connection reset by peer connection closed&quot;]]></title>
            <link href="/b/使用sftp時出現&quot;connection reset by peer connection closed&quot;"/>
            <updated>2016-06-24T00:00:00+08:00</updated>
            <id>/b/使用sftp時出現&quot;connection reset by peer connection closed&quot;</id>
            <content type="html"><![CDATA[<p>若新加的sftp帳戶發現，出現connection reset by peer connection closed的錯誤訊息，應該先用cat 查看/etc/rsyslog.conf了解找出出現
auth,authpriv.*　的行數，便清楚需要查看那個log file以獲取進一步的資訊。若系統是Centos，多數是查看/var/log/secure，ubuntu 則查看
/var/log/auth.log。</p>

<p>以下頁面清楚說明如何fix SFTP的問題，我遇到的情況是</p>

<pre><code>sshd[12399]: fatal: bad ownership or modes for chroot directory component "/path/of/chroot/directory/"
</code></pre>

<p>解決方法是確保chroot的路徑的所有資料夾都是由root 擁有及所有path都是安全的。若有任何一個資料夾的權限是777，應該把資料夾改為775或755。</p>

<p>參考 : <a href="https://wiki.archlinux.org/index.php/SFTP_chroot">https://wiki.archlinux.org/index.php/SFTP_chroot</a></p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[使用Apache設定Alias時出現403 Foridden]]></title>
            <link href="/b/使用Apache設定Alias時出現403 Foridden"/>
            <updated>2016-04-16T00:00:00+08:00</updated>
            <id>/b/使用Apache設定Alias時出現403 Foridden</id>
            <content type="html"><![CDATA[<p>這個錯誤其實是好常見的 ，如果在apache 看見 access denied because search permissions are missing on a component of the path ，
即表示<strong>根目錄至Alias 的目標資料夾</strong>中任意一個資料夾沒有execute permission!例如:</p>

<p>如果你alias的目標資夾是 <code>/usr/local/apache2/htdocs/foo</code> ，請確保以下資料夾有execute permission</p>

<p>/
/usr/
/usr/local/
/usr/local/apache2/
/usr/local/apache2/htdocs/
/usr/local/apache2/htdocs/foo/</p>

<p>owner 無須設定是apache user
因此，解決方法如下</p>

<pre><code>cd /usr/local/apache2/htdocs/foo

ls -la
chmod +x .
cd ..
# 重覆直至去到 /
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Failed to listen on localhost:8000 (reason: Address already in use)]]></title>
            <link href="/b/Failed to listen on localhost:8000 (reason: Address already in use)"/>
            <updated>2015-11-15T00:00:00+08:00</updated>
            <id>/b/Failed to listen on localhost:8000 (reason: Address already in use)</id>
            <content type="html"><![CDATA[<p>若使用 <code>php -S localhost:8000</code>來進行development時，沒有使用control +C 結束程序，便會發生該問題，因此可以建立以下bashscript結束名為"php"的proceses</p>

<pre><code class="bash">#!/bin/bash
pid=$(ps -fe | grep '[p]hp' | awk '{print $2}')
if [[ -n $pid ]]; then
    kill $pid
else
    echo "Does not exist"
fi
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Socket.io 1.3.5 cdn 同源問題]]></title>
            <link href="/b/Socket.io 1.3"/>
            <updated>2015-04-15T00:00:00+08:00</updated>
            <id>/b/Socket.io 1.3</id>
            <content type="html"><![CDATA[<p>假設己經有一個HTTPS加密網站，為了令網站更快速。因此Socket.io使用了以下的javascript cdn :</p>

<pre><code class="html">&lt;script src="https://cdn.socket.io/socket.io-1.3.4.js"&gt;&lt;/script&gt;
</code></pre>

<p>但是socket.io server 會在 polling的請求回覆400 Bad request</p>

<p>解決方法是從Socket.io依賴的原始碼找出return Access-Control-Allow-Origin Header的地方,根據socket.io v1.3.5 的源始碼,return Access-Control-Allow-Origin Header的地方位於node_modules/socket.io/node_modules/engine.io/lib/transports/polling-xhr.js</p>

<pre><code class="javascript">/**
 * Returns headers for a response.
 *
 * @param {http.ServerRequest} request
 * @param {Object} extra headers
 * @api private
 */

XHR.prototype.headers = function(req, headers){
  headers = headers || {};

  if (req.headers.origin) {
    headers['Access-Control-Allow-Credentials'] = 'true';
    headers['Access-Control-Allow-Origin'] = req.headers.origin;
  } else {
    headers['Access-Control-Allow-Origin'] = '*';
  }

  this.emit('headers', headers);
  return headers;
};
</code></pre>

<p>將該function 改成</p>

<pre><code class="javascript">/**
 * Returns headers for a response.
 *
 * @param {http.ServerRequest} request
 * @param {Object} extra headers
 * @api private
 */

XHR.prototype.headers = function(req, headers){
  headers = headers || {};

  if (req.headers.origin) {
    headers['Access-Control-Allow-Credentials'] = 'true';
    if(req.headers.origin == "https://www.example-domain.com/"){
        headers['Access-Control-Allow-Origin'] = "https://cdn.socket.io/";
    }else{
        headers['Access-Control-Allow-Origin'] = req.headers.origin;
    }
  } else {
    headers['Access-Control-Allow-Origin'] = '*';
  }

  this.emit('headers', headers);
  return headers;
};
</code></pre>

<p>或者直接新增　<code>headers['Access-Control-Allow-Origin'] = "https://cdn.socket.io/";</code>　雖然修改方法很醜。但至少可以令網站使用Socket.io CDN</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[如何令git repo 連接己經存在的heroku app?]]></title>
            <link href="/b/如何令git repo 連接己經存在的heroku app"/>
            <updated>2015-04-05T00:00:00+08:00</updated>
            <id>/b/如何令git repo 連接己經存在的heroku app</id>
            <content type="html"><![CDATA[<p>假設你己經在<a href="https://toolbelt.heroku.com/">https://toolbelt.heroku.com/</a>下載了heroku 工具程式.若想把原本的應用程式連接至heroku只需要在程式的根目錄輸入<code>heroku create</code>,但是這樣會建立了一個全新的heroku程式。</p>

<p>若我在heroku己經有一個應用程式為 project , 我想將原本的git 連接至 project 而不是重新建立一個新的應用程式,只需要在程式的根目錄輸入 <code>heroku git:remote -a project</code></p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Missing `secret_key_base` for &#039;production&#039; environment, set this value in `config/secrets.yml`]]></title>
            <link href="/b/Missing `secret_key_base` for &#039;production&#039; environment"/>
            <updated>2015-03-14T00:00:00+08:00</updated>
            <id>/b/Missing `secret_key_base` for &#039;production&#039; environment</id>
            <content type="html"><![CDATA[<p>執行<code>rake secret</code> 在.bashrc 或在apache 使用SetEnv指令 設定環境變數 SECRET_KEY_BASE 就完成了。不建議把 secret token 設定在 config/secrets.yml</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[如何令你使用SSH時更安全?]]></title>
            <link href="/b/如何令你使用SSH時更安全"/>
            <updated>2015-03-02T00:00:00+08:00</updated>
            <id>/b/如何令你使用SSH時更安全</id>
            <content type="html"><![CDATA[<p>要令SSH登入更安全，最簡單的方法是取消密碼登入。而使用公開金鑰。</p>

<p>在Client輸入</p>

<pre><code class="bash">ssh-keygen -t rsa
</code></pre>

<p>建議輸入passphrase。之後輸入</p>

<pre><code class="bash">chmod 700 ~/.ssh
</code></pre>

<p>之後將產生的Public Key (e.g id_rsa.pub) 複製至SSH Server。</p>

<p>登入SSH Server，將Public Key的內容加至 .ssh/authorized_keys:</p>

<pre><code class="bash">cat .ssh/id_rsa.pub &gt;&gt; .ssh/authorized_keys
</code></pre>

<p>之後開啟另一個Terminal 測試SSH登入是否只需要輸入passphrase來找替原本的使用者密碼</p>

<p>之後輸入<code>sudo vim /etc/ssh/sshd_config</code></p>

<p>將 Port 22 修改為其他Port，使用ssh 時用-p 選項指定PORT Number</p>

<p>將<code>#PasswordAuthentication yes</code> 改為<code>PasswordAuthentication no</code></p>

<p>重啟SSH Service就完成了</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[更新git branch所有舊有的電子郵件地址]]></title>
            <link href="/b/更新git branch所有舊有的電子郵件地址"/>
            <updated>2015-02-24T00:00:00+08:00</updated>
            <id>/b/更新git branch所有舊有的電子郵件地址</id>
            <content type="html"><![CDATA[<p>修改以下的OLD_EMAIL，CORRECT_NAME 及 CORRECT_EMAIL 的值再把以下script移至想更新的git repository 再執行就可以了</p>

<script src="https://gist.github.com/octocat/0831f3fbd83ac4d46451.js"></script>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[git://github.com/reactjs/react-rails.git (at master) is not yet checked out. Run `bundle install` first.]]></title>
            <link href="/b/react-rails.git (at master) is not yet checked out"/>
            <updated>2015-01-26T00:00:00+08:00</updated>
            <id>/b/react-rails.git (at master) is not yet checked out</id>
            <content type="html"><![CDATA[<p>根據<a href="https://github.com/bundler/bundler/blob/master/ISSUES.md">https://github.com/bundler/bundler/blob/master/ISSUES.md</a>，解決方是執行以下程式碼，重新安裝 dependencies :</p>

<pre><code class="bash"># remove user-specific gems and git repos
rm -rf ~/.bundle/ ~/.gem/bundler/ ~/.gems/cache/bundler/

# remove system-wide git repos and git checkouts
rm -rf $GEM_HOME/bundler/ $GEM_HOME/cache/bundler/

# remove project-specific settings
rm -rf .bundle/

# remove project-specific cached gems and repos
rm -rf vendor/cache/

# remove the saved resolve of the Gemfile
rm -rf Gemfile.lock

# uninstall the rubygems-bundler and open_gem gems
rvm gemset use global # if using rvm
gem uninstall rubygems-bundler open_gem

# try to install one more time
bundle install
</code></pre>
]]></content>
        </entry>
    </feed>